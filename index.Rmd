---
title: "Final Project"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
---

```{r setup, include=FALSE}
require(flexdashboard)
require(ggplot2)
require(plotly)
library(tidyverse)
library(gridExtra)
library(plotly)
library(cowplot)
library(tigris)
library(gghighlight)
library(statebins)
library(MetBrewer)
library(here)
library(colorblindr)
```

```{r}
#Load data
math_achievement <- rio::import("~/Documents/EDLD-652/finalproject/Data/Eighth-grade math achievement levels.xlsx")
science_achievement_1 <-  rio::import("~/Documents/EDLD-652/finalproject/Data/Eighth-grade science achievement levels.xlsx")
science_achievement_2 <-  rio::import("~/Documents/EDLD-652/finalproject/Data/Eighth-grade science achievement levels (1).xlsx")
funding <-  rio::import("~/Documents/EDLD-652/finalproject/Data/Per-pupil educational expenditures.xlsx")
```


```{r}
#Rearrange data
# Math 
#Rename column and covert data to numeric
math_achievement <- math_achievement %>% 
  rename("AchievementLevel" = "Achievement Level") %>% 
  mutate(Data = as.numeric(Data), TimeFrame = as.numeric(TimeFrame)) %>% 
   mutate(AchievementType = case_when(grepl("basic", AchievementLevel) ~ "Basic",
                            grepl("proficient", AchievementLevel, ignore.case = TRUE) ~"Proficient"),
          Subject = "Math") 
# Science
#rbind both science achievement files to create one with all years, rename column, and convert data to numeric
science_achievement <- rbind(science_achievement_1, science_achievement_2) %>% 
  rename("AchievementLevel" = "Achievement Level") %>% 
  mutate(Data = as.numeric(Data), TimeFrame = as.numeric(TimeFrame)) %>% 
   mutate(AchievementType = case_when(grepl("basic", AchievementLevel) ~ "Basic",
                            grepl("proficient", AchievementLevel, ignore.case = TRUE) ~"Proficient"),
          Subject = "Science") 
# Funding
#Convert numbers from character to numeric
funding$Data <- as.numeric(funding$Data)

# Math, 2019
math_2019 <- math_achievement %>% 
         filter(LocationType=="State" & TimeFrame==2019 & (AchievementLevel == "At or above basic" | AchievementLevel=="At or above proficient")) %>% 
  rename(NAME = Location) 

#Science, 2015
science_2015 <- science_achievement %>% 
         filter(LocationType=="State" & TimeFrame==2015 & (AchievementLevel == "At or above basic" | AchievementLevel=="At or above proficient")) %>% 
  rename(NAME = Location) 
```


```{r}
#Set defaults
theme_set(theme_minimal())

options(ggrepel.max.overlaps = 25)
```


Sidebar Title {.sidebar}
==========================

The data used for this project come from the KIDS COUNT Study, which is conducted by the Annie E. Casey Foundation (https://datacenter.kidscount.org/). Data is collected at both the national level and the state level within the US. The KIDS COUNT project contains data related to a number of different aspects of child development and well-being, including education, health, risky behavior, and family/community relationships. 

For the specific research questions Iâ€™m interested in looking at, achievement data are available for fourth and eighth graders. Data were available from 2003-2022, though not all types of data were collected every year. Data are available per state as well as nationally. Achievement data are represented using 4 categories (below basic, at or above basic, below proficient, at or above proficient). The proficient and basic categories are calculated separately, so all students performing "above proficient" are also included as performing "above basic".  

Achievement levela are as measured and defined by the National Assessment of Educational Progress (NAEP).

Question 1
===================================== 

**How has educational achievement in math and science changed over time?**

In the earlier version of this figure, I plotted all of the available data, and showed math and science achievement separately. This was helpful to get a feel for the data, but it was difficult to get the main takeaways from the figure with a quick glance. I tried a few different ways of making the plot, and peer review helped me to decide which one was the best way of showing the data. For the final version, I made a couple of major changes. First, I dropped the lines that showed the proportion of students below basic and below proficient. Since the plot already showed the proportion of students above basic and above proficient, this was redundant information. This also helped to reduce the number of colors happening in the plot, as it no longer needs a four-color legend. I also switched to a color palette that had more distinct colors, and checked the new plot with cvd_grid() to see if the new colors were colorblind-friendly. Additionally, I put both math and science achievement on the same plot, making them easier to compare. For the final plot, I used both color and line types to convey the information in the plot. Color is used to differentiate between subjects, while line types (solid versus dashed) show the different achievement levels.      

Row {.tabset data-height=400}
-----------------------------------------

### Figure 1 

```{r}
subject_achievement_plot <- ggplot() + 
geom_line(data=science_achievement %>% 
  filter(Location=="United States", AchievementLevel == "At or above proficient"| AchievementLevel=="At or above basic"), aes(x=TimeFrame, y=Data, group = AchievementLevel, color=Subject, linetype=AchievementLevel)) + 
   geom_line(data=math_achievement %>% 
  filter(Location=="United States", AchievementLevel == "At or above proficient"| AchievementLevel=="At or above basic"), aes(x=TimeFrame, y=Data, group = AchievementLevel, color=Subject, linetype=AchievementLevel)) + 
  scale_color_manual(values=met.brewer("Renoir", 2)) +
  labs(x="School Year", y = "Proportion", title = "8th Grade Science & Math Achievement (US average)", linetype= "Achievement Level") 

subject_achievement_plot
```

### Check for colorblind visibility
```{r}
cvd_grid(ggplot() + 
geom_line(data=science_achievement %>% 
  filter(Location=="United States", AchievementLevel == "At or above proficient"| AchievementLevel=="At or above basic"), aes(x=TimeFrame, y=Data, group = AchievementLevel, color=Subject, linetype=AchievementLevel)) + 
   geom_line(data=math_achievement %>% 
  filter(Location=="United States", AchievementLevel == "At or above proficient"| AchievementLevel=="At or above basic"), aes(x=TimeFrame, y=Data, group = AchievementLevel, color=Subject, linetype=AchievementLevel)) + 
  scale_color_manual(values=met.brewer("Renoir", 2)) +
  labs(x="School Year", y = "Proportion",  linetype= "Achievement Level") )

```


### Previous Version

```{r}
science_plot <- science_achievement %>% 
  filter(Location=="United States") %>% 
  ggplot(aes(x=TimeFrame, y=Data, group = AchievementLevel, color=AchievementLevel)) +
   geom_point() +
  geom_line() +
  scale_color_manual(values=met.brewer("Morgenstern", 4)) +
  labs(x="School Year", y = "Proportion", title = "Science Achievement (US average)", color = "Achievement Level")

math_plot <- math_achievement %>% 
  filter(Location=="United States") %>% 
  ggplot(aes(x=TimeFrame, y=Data, group = AchievementLevel, color=AchievementLevel)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values=met.brewer("Morgenstern", 4)) +
  labs(x="School Year", y = "Proportion", title = "Math Achievement (US average)", color = "Achievement Level")+
  theme(axis.text.x = element_text( angle = 45))

grid.arrange(science_plot, math_plot)
```



   
Question 2
=====================================   

**How does educational achievement in math and science differ across states?**

For this set of plots, I originally used the geom_sf() function to make a more traditional map of the US. However, geom_sf() took an incredibly long time to load, and resulted in some messages/documentation of the package loading that still showed up in the knitted document. Additionally, the traditional map makes it difficult to see what's happening in geographically smaller states. To solve those problems, I switched to using the statebins package instead. The statebins package represents each state as a square of the same size, making it easier to see smaller states. The statebins package also labels each state, which is helpful for interpretation. The one issue I ran into with the package was when trying to facet the plots. Originally, I was trying to make a plot for each subject at one timepoint, and facet by achievement level. However, these plots always looked squished, and the state labels were difficult to read. As a solution, I switched to using a dashboard, where I could just make tabs for the different achievement levels. Based on feedback, I also updated the labels on the plots, including the title, subtitle, and legend labels. 

Row {data-height=400}
-----------------------------------------
  
### Figure 1A

```{r}
statebins(science_2015 %>% filter(AchievementLevel == "At or above basic"),
state_col = "NAME",
value_col = "Data") +
  scale_fill_gradientn(colors=met.brewer("Morgenstern")) +
    labs(title= "Science achievement has regional differences", subtitle = "Science Achievement, Basic (2015)", fill = "Proportion at\nor above basic") +
  theme_statebins("right")

```

### Figure 1B

```{r}
statebins(science_2015 %>% filter(AchievementLevel == "At or above proficient"),
state_col = "NAME",
value_col = "Data") +
  scale_fill_gradientn(colors=met.brewer("Morgenstern")) +
    labs(title= "Science achievement has regional differences", subtitle = "Science Achievement, Proficient (2015)", fill = "Proportion at\nor above proficient") +
  theme_statebins("right")
```

Row {data-height=400}
-----------------------------------------
### Figure 2A
```{r}
statebins(math_2019 %>% filter(AchievementLevel == "At or above basic"),
state_col = "NAME",
value_col = "Data") +
    scale_fill_gradientn(colors=met.brewer("Morgenstern")) +
    labs(title= "Math achievement has regional differences", subtitle = "Math Achievement, Basic (2019)", fill = "Proportion at\nor above basic") +
  theme_statebins("right")
```

### Figure 2B
```{r}
statebins(math_2019 %>% filter(AchievementLevel == "At or above proficient"),
state_col = "NAME",
value_col = "Data") +
    scale_fill_gradientn(colors=met.brewer("Morgenstern")) +
      labs(title= "Math achievement has regional differences", subtitle = "Math Achievement, Proficient (2019)", fill = "Proportion at\nor above proficient") +
  theme_statebins("right")

```

Row {.tabset data-height=400}
-----------------------------------------
### Previous Science Plot
```{r}
ggplot(science_2015, aes(state=NAME, fill=Data)) +
  geom_statebins() +
  coord_equal() +
  scale_fill_gradientn(colors=met.brewer("Morgenstern")) +
  facet_wrap(~AchievementLevel) +
  labs(title="Science Achievement (2015)") +
  theme_statebins("right")
```

### Previous Math Plot
```{r}
ggplot(math_2019, aes(state=NAME, fill=Data)) +
  geom_statebins() +
  scale_fill_gradientn(colors=met.brewer("Morgenstern")) +
  facet_wrap(~AchievementLevel) +
  labs(title="Math Achievement (2019)") +
  theme_statebins("right")
```


Question 3
=====================================     

**a. How does funding differ between states?**

**b. How has funding for education changed over time?** 

**c. How have changes in funding differed between states?**

These plots were inspired by the problem of trying to find a feasible way to represent data from all 50 states in the same figure. To make a readable figure with all 50 states represented, I tried to make a circular bar plot. For my first version, I made a circular bar plot based on per-student expenditures averaged over the time period for which I had data. In the first version, the states were just organized alphabetically. Based on feedback, I tried grouping the states by funding quantiles, colored the plot by groups, and added space between each quantile. I also added labels for each quantile, and changed the scaling of the data to make bars fit into the circular plot more smoothly, and adjusted the label alignment to make them easier to read. I also checked whether the default colors for the groupings were colorblind-friendly. While they worked for three of the four types of colorblindness included in the cvd_grid() function, for the fourth version, all groups looked the same. I changed the colors to a colorblind-friendly pallette, and checked the new colors against cvd_grid(). Based on additional feedback, I also sorted the bars within each quantile by their value. For both the circular bar plot and the line plot underneath, I added more informative titles. 

```{r} 
#, fig.width=4, fig.height=2.5
funding_plot <- funding %>% 
  filter(Location=="United States") %>% 
  ggplot(aes(x=TimeFrame, y=Data)) +
  geom_line(aes(group=1)) +
  labs(x="Year", y = "Dollars", title = "Per-student spending (US average)", caption="Not adjusted for inflation")+
  scale_fill_gradientn(colors=met.brewer("Morgenstern")) +
  theme(axis.text.x = element_text(size=6, angle = 45))
```

```{r}
# filter for just states
filtered_funding <- funding %>%  
  filter(LocationType=="State") %>% 
# average across years
  select(Location, TimeFrame, Data) %>% 
  group_by(Location) %>% 
  summarise(avg_funding = mean(Data, na.rm=T)/100) %>%  #, across(Region)
  ungroup() %>% 
  #mutate(observation = 1:n()) %>% 
  mutate(quantile = as.factor(ntile(avg_funding, 4)))

# Set a number of 'empty bar' to add at the end of each group
empty_bar <- 4
to_add <- data.frame( matrix(NA, empty_bar*nlevels(filtered_funding$quantile), ncol(filtered_funding)) )
colnames(to_add) <- colnames(filtered_funding)
to_add$quantile <- rep(levels(filtered_funding$quantile), each=empty_bar)
funding_groups <- rbind(filtered_funding, to_add)
funding_groups <- funding_groups %>% arrange(quantile)
funding_groups$id <- seq(1, nrow(funding_groups))

#create labels
label_data <- funding_groups
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# prepare a data frame for base lines
base_data <- funding_groups %>% 
  group_by(quantile) %>% 
  summarize(start=min(id), end=max(id) - empty_bar) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))

```


Row {.tabset data-height=400}
-----------------------------------------

### Figure 1 - Ordered within groups

```{r}
#Plot ordered by values
filtered_funding_ordered <- filtered_funding %>% 
  arrange(avg_funding) 

to_add_ordered <- data.frame( matrix(NA, empty_bar*nlevels(filtered_funding$quantile), ncol(filtered_funding)) )
colnames(to_add_ordered) <- colnames(filtered_funding_ordered)
to_add_ordered$quantile <- rep(levels(filtered_funding_ordered$quantile), each=empty_bar)
funding_groups_ordered <- rbind(filtered_funding_ordered, to_add_ordered)
funding_groups_ordered <- funding_groups_ordered %>% arrange(quantile)
funding_groups_ordered$id <- seq(1, nrow(funding_groups_ordered))

#create labels
label_data_ordered <- funding_groups_ordered
number_of_bar_ordered <- nrow(label_data_ordered)
angle <- 90 - 360 * (label_data_ordered$id-0.5) /number_of_bar_ordered     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data_ordered$hjust <- ifelse( angle < -90, 1, 0)
label_data_ordered$angle <- ifelse(angle < -90, angle+180, angle)

# prepare a data frame for base lines
base_data_ordered <- funding_groups_ordered %>% 
  group_by(quantile) %>% 
  summarize(start=min(id), end=max(id) - empty_bar) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))
```


```{r}
p_ordered <- ggplot(funding_groups_ordered, aes(x=as.factor(id), y=avg_funding, fill=quantile)) +      
  geom_bar(stat="identity", alpha=0.5) +
  # Limits of the plot = very important. The negative value controls the size of the inner circle, the positive one is useful to add size over each bar
  ylim(-80,200) +
   labs(title = "Educational spending varies between states", subtitle="Per-student expenditures averaged over 1999-2019") + 
  theme_minimal() +
  scale_fill_manual(values=met.brewer("Renoir", 4)) +
  theme(
    #plot.title = element_text(hjust = 0.5, unit(c(2.1, 0, -1, 0), "cm")),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    legend.position="none",
    plot.margin = unit(rep(.5,4), "cm")      # Adjust the margin to make in sort labels are not truncated!
  ) +
  coord_polar(start = 0) +
  # Add the labels, using the label_data dataframe that we have created before
  geom_text(data=label_data_ordered, aes(x=id, y=avg_funding+10, label=Location, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=2.5, angle= label_data$angle, inherit.aes = FALSE ) +
  
  # Add base line information
  geom_segment(data=base_data_ordered, aes(x = start, y = -5, xend = end, yend = -5), colour = "black", alpha=0.8, size=0.6 , inherit.aes = FALSE) +
  geom_text(data=base_data_ordered, aes(x = title, y = -18, label=quantile), hjust=c(1,1,0,0), colour = "black", alpha=0.8, size=4, fontface="bold", inherit.aes = FALSE)
 
p_ordered
```

### Check for colorblind visibility
```{r}
cvd_grid(p_ordered)
```
    
### Prior Version - No ordering within groups    
    

```{r}
#Plot

p <- ggplot(funding_groups, aes(x=as.factor(id), y=avg_funding, fill=quantile)) +      
  geom_bar(stat="identity", alpha=0.5) +
  # Limits of the plot = very important. The negative value controls the size of the inner circle, the positive one is useful to add size over each bar
  ylim(-100,185) +
  labs(title = "Educational spending varies between states", subtitle="Per-student expenditures averaged over 1999-2019") + 
  theme_minimal() +
  theme(
    #plot.title = element_text(hjust = 0.5, unit(c(2.1, 0, -1, 0), "cm")),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    legend.position="none",
    plot.margin = unit(rep(.5,4), "cm")      # Adjust the margin to make in sort labels are not truncated!
  ) +
  coord_polar(start = 0) +
  # Add the labels, using the label_data dataframe that we have created before
  geom_text(data=label_data, aes(x=id, y=avg_funding+10, label=Location, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=2.5, angle= label_data$angle, inherit.aes = FALSE ) +
    geom_segment(data=base_data, aes(x = start, y = -5, xend = end, yend = -5), colour = "black", alpha=0.8, size=0.6 , inherit.aes = FALSE) +
  geom_text(data=base_data, aes(x = title, y = -18, label=quantile), hjust=c(1,1,0,0), colour = "black", alpha=0.8, size=4, fontface="bold", inherit.aes = FALSE)
 
p
```

### Check for colorblind visibility
```{r}
cvd_grid(p)
```


### Prior version - No groups
```{r}
# filter for just states
filtered_funding <- funding %>%  
  filter(LocationType=="State") %>% 
# average across years
  select(Location, TimeFrame, Data) %>% 
  group_by(Location) %>% 
  summarise(avg_funding = mean(Data, na.rm=T)) %>%  #, across(Region)
  ungroup() %>% 
  mutate(observation = 1:n())


# ----- This section prepare a dataframe for labels ---- #
# Get the name and the y position of each label
label_data <- filtered_funding
 
# calculate the ANGLE of the labels
number_of_bar <- nrow(label_data)
angle <-  90 - 360 * (label_data$observation-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
 
# calculate the alignment of labels: right or left
# If I am on the left part of the plot, my labels have currently an angle < -90
label_data$hjust<-ifelse( angle < -90, 1, 0)
 
# flip angle BY to make them readable
label_data$angle<-ifelse(angle < -90, angle+180, angle)
# ----- ------------------------------------------- ---- #
```

```{r}
#Plot

# Start the plot
p <- ggplot(filtered_funding, aes(x=as.factor(Location), y=avg_funding)) +       # Note that id is a factor. If x is numeric, there is some space between the first bar
  
  # This add the bars with a blue color
  geom_bar(stat="identity", fill=alpha("skyblue", 0.7)) +
  
  # Limits of the plot = very important. The negative value controls the size of the inner circle, the positive one is useful to add size over each bar
  ylim(-100,18000) +
  
   labs(title = "Per-student expenditures", subtitle="Averaged over 1999-2019") +   #

  
  # Custom the theme: no axis title and no cartesian grid
  theme_minimal() +
  theme(
    #plot.title = element_text(hjust = 0.5, unit(c(2.1, 0, -1, 0), "cm")),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(.5,4), "cm")      # Adjust the margin to make in sort labels are not truncated!
  ) +
  
  # This makes the coordinate polar instead of cartesian.
  coord_polar(start = 0) +
  
  # Add the labels, using the label_data dataframe that we have created before
  geom_text(data=label_data, aes(x=observation, y=avg_funding+100, label=Location, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=2.5, angle= label_data$angle, inherit.aes = FALSE )
 
p
```


Row {data-height=400}
-----------------------------------------

### Chart L

```{r}
#Line Plot for state funding

funding %>% 
  filter(LocationType=="State") %>% 
  ggplot(aes(x=TimeFrame, y=Data, group = Location, color=Location)) +
  geom_line() +
    gghighlight(max(Data) > 20000|(max(Data) < 9250)) +
  scale_color_manual(values=met.brewer("Hiroshige", 10)) + #Derain
  labs(x="Year", y = "Dollars", title = "Per-student spending has increased over time", subtitle = "Gaps in per-student spending have increased as well", caption="Not adjusted for inflation") +
  theme(axis.text.x = element_text(size=6, angle = 45, vjust = 1, hjust=1))
```


